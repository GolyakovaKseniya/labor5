# Задание 1
## Задача 1
### Текст задачи
В класс Дробь, добавить интерфейс на два метода: получение вещественного значения, установка числителя и установка знаменателя. Сгенерировать такую версию дроби, которая будет кэшировать вычисление вещественного значения. Если раннее в вашем варианте не было Дроби, то создайте сущность Дробь со следующими особенностями: • Имеет числитель: целое число • Имеет знаменатель: целое число • Дробь может быть создана с указанием числителя и знаменателя • Может вернуть строковое представление вида “числитель/знаменатель” • Необходимо корректно обрабатывать отрицательные значения. Учтите, что знаменатель не может быть отрицательным. • Переопределите метод сравнения объектов по состоянию таким образом, чтобы две дроби считались одинаковыми тогда, когда у них одинаковые значения числителя и знаменателя.
### Алгоритм решения
Создаем интерфейс 2 методами: получение вещественного значения и установка дроби (установка числителя и знаменателя в одном). Класс, являющийся реализацией интерфейса, со стандартной дробью со всеми прописанными особенности в условии задачи. Далее создаем класс с кэшированием, наследующий класс с обычной дробью. Объявляем Map, который будет хранить пары ключ-значение (дробь как строка и ее вещественное значение), в конструкторе вызываем конструктор родительского класса. Далее переопределенный метод для получения вещественного значения, в нем создаем ключ, потом смотрим, есть ли уже этот ключ в Map, если есть - сразу выводим его значение, если нет, то вызываем родительский метод, сохраняем в Map и возвращаем полученное значение. В сеттере, то есть при изменении дроби, берем старый ключ и если он уже есть, то удаляем его и изменяем дробь. В методе main создаем с помощью интерфейса дробь с кешированием, получаем 1 значение (оно вычисляется, так как его нет в кэше), получаем 2 значение (оно берется уже из кэша, так как дробь та же самая). Далее изменить числитель, и получим 3 значение, уже другое, снова заново вычислялось, и получим 4 значение (берем из кэша, дробь не изменилась).
#### Пример вывода
1)
Введите числитель: 1
Введите знаменатель: 2
Дробь с кэшированием: 1/2
Первое вычисление: 0.5
Второе вычисление: 0.5
Кэш содержит 1 значений: {1/2=0.5}
Введите новый числитель: 3
[КЭШ] Удалено старое значение: 1/2
Вычисление 3: 1.5
Вычисление 4: 1.5
Кэш содержит 1 значений: {3/2=1.5}


# Задание 2
## Задача 1
### Текст задачи
Количество мяуканий. Необходимо воспользоваться классом Кот и методом принимающим всех мяукающих из задачи 2.5.4. Необходимо таким образом передать кота в указанный метод, что бы после окончания его работы узнать сколько раз мяукал кот за время его работы. На рисунке показан пример работы. Перед вызовом метода создаем кота, отправляем ссылку на кота в метод, после окончания его работы выводим количество мяуканий на экран. Кота изменять нельзя. Если раннее в вашем варианте не было Кота, то создайте 1. сущность Кот, которая описывается следующим образом: • Имеет Имя (строка) • Для создания необходимо указать имя кота. • Может быть приведен к текстовой форме вида: “кот: Имя” • Может помяукать, что приводит к выводу на экран следующего текста: “Имя: мяу!”, вызвать мяуканье можно без параметров. 2. интерфейс Мяуканье: разработайте метод, который принимает набор объектов способных мяукать и вызывает мяуканье у каждого объекта. Мяукающие объекты должны иметь метод со следующей сигнатурой: public void meow();
### Алгоритм решения
Создаем интерфейс, содержащий один метод с мяуканьем, далее создаем класс Кот со всеми условиями, указанными в задаче, который будет реализацией интерфейса, прописываем переопределенный метод для мяуканья и тд. Далее создаем класс для подсчета мяуканья, он тоже является реализацией интерфейса. Прописываем для него 2 поля, геттеры, количество мяуканий и оригинальный кот. Конструктор принимает объект кота, в нем инициализируем счетчик 0 и кота. Далее метод мяуканья, вызываем в нем метод у оригинального кота и увеличиваем счетчик. Создаем метод, принимающий набор объектов, способных мяукать. В нем проходим по всем объектам и выводим мяу заданное количество раз. В методе main создаем кота с введенным именем, далее оборачиваем кота, то есть добавляем ему функциональность, далее объявляем массив объектов, реализующих интерфейс, вызываем созданный метод с мяуканьем
#### Пример вывода
1)
Введите имя кота: Барсик
Создан: Кот: Барсик
Барсик: мяу!
Барсик: мяу!
Барсик: мяу!
Барсик: мяу!
Барсик: мяу!
Барсик: мяу!
Барсик: мяу!
Результаты: 
Кот: Барсик [мяукал: 7 раз]



# Задание 3
## Задача 9
### Текст задачи
Составить программу, которая формирует список L включив в него по одному разу элементы, которые входят в один из списков L1 и L2, но в то же время не входит в другой из них.
### Алгоритм решения
Так как в условии задачи не сказано, какой конкретный тип элементов содержится в списках, необходимо создать обобщенный метод с типовой переменной, который будет принимать три списка (2 исходных и результирующий) одинакового типа. В нем проходим по элементам 1 списка и, если текущий элемент не содержится и во 2 списке и в результирующем, то добавляем его в список с результатом. В методе main даем выбор пользователю с каким типом нужно работать. Далее создаем два списка с выбранным типом, запрашиваем ввод определенного количества элементов и добавляем в списки. Потом создаем 3 список с результатом и применяем метод два раза, но в качестве первого параметра будут использованы разные списки. И выводим результат. 
#### Пример вывода
1)
Введите количество чисел для списка L1: 4
Введите элементы списка L1: 1, 2, 3, 4
Введите количество чисел для списка L2: 4
Введите элементы списка L2: 3, 4, 5, 6
Результат: 
Список L1: [1, 2, 3, 4]
Список L2: [3, 4, 5, 6]
Результат (список L): [1, 2, 5, 6]
2)
Введите количество элементов для списка L1: 3
Введите элементы списка L1:
Элемент 1: яблоко
Элемент 2: апельсин
Элемент 3: киви
Введите количество элементов для списка L2: 2
Введите элементы списка L2:
Элемент 1: мандарин
Элемент 2: манго
Результат: 
Список L1: [яблоко, апельсин, киви]
Список L2: [мандарин, манго]
Результат (список L): [яблоко, апельсин, киви, мандарин, манго]

# Задание 4
## Задача 4
### Текст задачи
В некотором вузе абитуриенты проходят предварительное тестирование, по результатам которого могут быть допущены к сдаче вступительных экзаменов в первом потоке. Тестирование проводится по двум предметам, по каждому предмету абитуриент может набрать от 0 до 100 баллов. При этом к сдаче экзаменов в первом потоке допускаются абитуриенты, набравшие по результатам тестирования не менее 30 баллов по каждому из двух предметов. На вход программы подаются сведения о результатах предварительного тестирования. Известно, что общее количество участников тестирования не превосходит 500. В первой строке вводится количество абитуриентов, принимавших участие в тестировании, N. Далее следуют N строк, имеющих следующий формат: Здесь – строка, состоящая не более чем из 20 символов;– строка, состоящая не более чем из 15 символов;– строка, содержащая два целых числа, разделенных пробелом, соответствующих баллам, полученным на тестировании по каждому из двух предметов. При этом и , и разделены одним пробелом. Примеры входных строк: Ветров Роман 68 59 Анисимова Екатерина 64 88 Напишите программу, которая будет выводить на экран фамилии и имена абитуриентов, потерпевших неудачу, то есть не допущенных к сдаче экзаменов в первом потоке. При этом имена и фамилии можно выводить в произвольном порядке.
### Алгоритм решения
По условию задачи данные хранятся в файле, в методе main считываем: 1 строка - количество людей, преобразуем в число, далее проходим по этому количеству строк, разбиваем каждую по пробелам, чтобы можно было работать с отдельными частями. Если этих частей было достаточно, то объединяем фамилию и имя в одну строку, а оценки преобразуем в числа и добавляем эту запись в map. Далее вызываем метод, который обрабатывает данные об абитуриентах. В этом методе, который принимает карту с уже собранными данными, проходим по всем парам, которые хранятся в Map, получаем имя и оценки абитуриента. Проверяем, что если хотя бы одна оценка меньше 30, то мы выводим имя абитуриента, если людей с такими данными нет, то выводим об этом сообщение.
#### Пример вывода
1)
Файл:
5
Ветров Роман 68 59
Анисимова Екатерина 64 88
Петров Иван 25 45
Сидорова Мария 35 28
Петухова Мария 20 39
Вывод:

Абитуриенты, не допущенные к экзаменам: 
Петухова Мария 20 39
Петров Иван 25 45
Сидорова Мария 35 28
Всего абитуриентов: 5
Не допущенных абитуриентов: 3 


# Задание 5
## Задача 5
### Текст задачи
Файл содержит текст на русском языке. Напечатать в алфавитном порядке все звонкие согласные буквы, которые входят более чем в одно слово.
### Алгоритм решения
Так как по условию задачи данные, хранятся в файле, то считываем его. Создаем множество для всех слов, считываем файл построчно, пока строка не пустая. Далее разбиваем ее по символам, которые не являются русскими буквами, на слова и приводим их к нижнему регистру, чтобы не было ошибок с вычислением. Потом проходим по каждому слову из списка слов строки и если слово не пустое, то добавляем в множество. Создаем неизменяемое множество звонких согласных букв. И далее вызываем метод для нахождения звонких согласных в словах. В методе, который принимает множество всех слов и множество звонких согласных, объявляем множество с результатом, который для алфавитного порядка использует реализацию TreeSet. Далее проходим по каждой согласной из переданного множества, объявляем счетчик, проходим по словам и, если слово содержит текущую звонкую согласную, увеличиваем счетчик. И если он будет больше 1, то добавляем эту согласную в множество с результатом. И возвращаем это множество. В методе main проходим по каждой согласной из множества с результатом и выводим их.
#### Пример вывода
1)
Файл: 
Большой дом стоял на берегу реки, а рядом рос дуб.
Вася вася
Вывод: 
Звонкие согласные, которые входят в более чем 1 слово: 
б д л м р

# Задание 6
## Задача 1
### Текст задачи
Напечатать в обратном порядке элементы непустой очереди L.
### Алгоритм решения
Так как в условии задачи не сказано, какой конкретный тип элементов содержится в очереди, необходимо создать обобщенный метод с типовой переменной, который будет принимать очередь какого-то типа. В методе проверяем, что очередь не пустая, далее передвигаем ее элементы так, чтобы нужный нам оказался в «голове», далее извлекаем его, выводим и вставляем обратно в очередь. Далее, чтобы очередь не была изменена снова перемещаем элементы. В методе main даем выбор пользователю с каким типом нужно работать. Далее создаем очередь с выбранным типом, запрашиваем ввод определенного количества элементов и добавляем в нее. Выводим исходную, а потом применяем к ней метод.
#### Пример вывода
1)
Введите количество чисел для очереди: 4
Введите элементы очереди:
Число 1: 1
Число 2: 2
Число 3: 3
Число 4: 4
Исходная очередь: [1, 2, 3, 4]
Элементы в обратном порядке: 4 3 2 1
2)
Введите количество элементов очереди: 3
Введите элементы очереди:
Элемент 1: qw
Элемент 2: asd
Элемент 3: zx
Исходная очередь: [qw, asd, zx]
Элементы в обратном порядке: zx asd qw

# Задание 7
## Задача 1
### Текст задачи
Необходимо написать стрим: Дан набор объектов типа Point, необходимо взять все Point в разных координатах, убрать с одинаковыми X,Y, отсортировать по X, отрицательные Y сделать положительными и собрать это все в ломаную (объект типа Polyline) Если раннее в вашем варианте не было задание с классом Point и Polyline, то написать их: 1. класс Point: • Координата Х: число. • Координата Y: число. • Может возвращать текстовое представление вида “{X;Y}”. 2. класс Line (Линия), расположенная на двумерной плоскости, которая описывается: • Координата начала: Точка • Координата конца: Точка • Может возвращать текстовое представление вида “Линия от {X1;Y1} до {X2;Y2}” 3. класс Polyline (Ломаная), которая будет представлять собой ломаную линию. Ломаная линия представляет собой набор следующих характеристик: • Имеет массив Точек, через которые линия проходит. • Может быть приведена к строковой форме вида “Линия [Т1,T2,…,TN]”, где TN – это результат приведения к строке Точки с номером N
### Алгоритм решения
Создаем 3 необходимых класса, с полями, конструкторами, геттерами и методом toString. В методе main создаем список для точек, далее запрашивается ввод координат, добавляем их в список. Создаем стрим для обработки последовательности данных, в нем мы удаляем дубликаты (distinct); сортируем по Х (sorted), сравнивая как целые числа; преобразуем каждую точку (map), создавая новую, но с модулем координаты Y, и преобразуем элементы из стрима в Ломаную (collect), то есть собираем их в список и создаем с ним ломаную. И выводим.
#### Пример вывода
1)
Введите количество точек: 4
Введите точки: 
Точка 1: 4, -1
Добавлена точка: {4;-1}
Точка 2: 1, 2
Добавлена точка: {1;2}
Точка 3: 1, 2 
Добавлена точка: {1;2}
Точка 4: 0, -3 
Добавлена точка: {0;-3}
Всего точек: 4
Исходные точки: [{4;-1}, {1;2}, {1;2}, {0;-3}]
Результат (ломаная) : Линия [{0;3}, {1;2}, {4;1}]


# Задание 7
## Задача 2
### Текст задачи
Дан текстовый файл со строками, содержащими имя человека и его номер в следующей форме: Вася:5 Петя:3 Аня:5 Номера людей могут повторяться. У каких-то людей может не быть номера. Необходимо написать стрим выполняющую следующее: читаются все люди из файла, все имена приводится к нижнему регистру, но с первой буквой в верхнем регистре, убираем из перечня всех людей без номеров, а имена оставшихся группируются по их номеру: [5:[Вася, Аня], 3:[Петя]]
### Алгоритм решения
Считываем файл в map сразу со стримом, далее преобразуем строку, то есть разбиваем ее по «:», чтобы можно работать с отдельными частями строки; фильтруем: строка должна состоять из 2 частей (имени и числа) и число не должно быть пустым; группируем по номеру (строку делаем числом), далее преобразуем значение, первую букву имени переводим в верхний регистр, все остальные в нижний и собираем все элементы в список. 
#### Пример вывода
1)
Файл:
Вася:5
Петя:3
Аня:5
Настя:
АНя:2
ксюша:4
соня:1
Вывод:
{1=[Соня], 2=[Аня], 3=[Петя], 4=[Ксюша], 5=[Вася, Аня]}
